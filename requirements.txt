# -*- coding: utf-8 -*-
"""
Merged Pro Futures Signal Bot + Whale Watcher (single file)
- Full-market scan (USDT futures)
- Analyze 15m, 6h, 3d
- Send BUY/SELL signals to Telegram channel (Arabic)
- Monitor signals for targets/stoploss/rebound (smart threshold)
- WebSocket whale watcher (Binance Futures aggTrade stream)
- Ping external projects every minute (keep-alive)
- Flask keep-alive for Replit
- Monitor active trades every 15 seconds
"""
from flask import Flask
from threading import Thread
import requests, time, math, threading, pickle, os, json, sys, subprocess
from datetime import datetime

# --------------------------- USER CONFIG ----------------------------------
TELEGRAM_BOT_TOKEN = "8206009357:AAEwX9C8BaSGKQIlTSJ8p8DX1nt-pXohTQY"
TELEGRAM_CHAT_ID = "@gahajaqjajakwj"

BINANCE_FAPI = "https://fapi.binance.com"
USER_AGENT = "ProFuturesNoDepsBot/1.0"

FULL_SCAN_INTERVAL = 4 * 60 * 60    # 4 hours full scan
SLEEP_BETWEEN_REQUESTS = 0.25
LIGHT_BATCH_SIZE = 20
LIGHT_BATCH_SLEEP = 2
MIN_CANDLES = 60
COOLDOWN_SECONDS = 60 * 30          # 30min dedupe
PERSIST_FILE = "bot_state_singlefile.pkl"
MODEL_FILE = "bot_model.pkl"
STATUS_INTERVAL = 5 * 60            # status every 5 minutes
MONITOR_INTERVAL = 15               # check active trades every 15s
VOL_LOOKBACK = 20                   # candles for volatility
EXPLOSION_VOL_MULTIPLIER = 3.0

# Ping (keep-alive) config
PING_URLS = [
    "https://7a48abd2-1edc-43f3-bd30-eb8146c74a7b-00-25cejf5bn2g50.sisko.replit.dev/",
    "https://replit.com/@hshshsyawihhsjs/EthicalDoubleMemoryallocator"
]
PING_INTERVAL = 60                   # ping each minute
SEND_PING_TO_TELEGRAM = False        # set True to notify channel each ping (can spam)

# Whale watcher config
WHALE_THRESHOLD = 100_000.0          # USDT threshold to consider "whale" trade
BINANCE_WS = "wss://fstream.binance.com/ws/!aggTrade@arr"
WS_RECONNECT_DELAY = 5

# ---------------------------------------------------------------------------

# -------------------- ensure websocket-client available --------------------
try:
    import websocket
except Exception:
    try:
        print("[setup] websocket-client not found, attempting to install...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", "websocket-client", "--quiet"])
        import websocket
        print("[setup] websocket-client installed.")
    except Exception as e:
        print("[setup] failed to install websocket-client:", e)
        websocket = None

# --------------------------- Flask keep-alive ------------------------------
app = Flask(__name__)

@app.route("/")
def home():
    return "âœ… Ø§Ù„Ø¨ÙˆØª Ø´ØºØ§Ù„ Ø¨Ù†Ø¬Ø§Ø­"

def run_flask():
    # Replit expects port 8080
    app.run(host="0.0.0.0", port=8080)

def keep_alive():
    t = Thread(target=run_flask, daemon=True)
    t.start()

# --------------------------- persistence -----------------------------------
class State:
    def __init__(self, path=PERSIST_FILE):
        self.path = path
        self.data = {
            "sent_signals": {},   # symbol -> {sig, sent_at, monitored, last_price, rebound_threshold}
            "stats": {"scans": 0, "signals": 0, "wins": 0, "losses": 0, "symbols_count": 0},
            "last_seen": None
        }
        self._load()

    def _load(self):
        if os.path.exists(self.path):
            try:
                with open(self.path, "rb") as f:
                    self.data = pickle.load(f)
                print("[state] loaded", self.path)
            except Exception as e:
                print("[state] load error:", e)

    def save(self):
        try:
            with open(self.path, "wb") as f:
                pickle.dump(self.data, f)
        except Exception as e:
            print("[state] save error:", e)

STATE = State()

# ---------------------- simple online model (very small) -------------------
class SimpleLinearModel:
    def __init__(self, n=8, lr=0.03):
        self.n = n; self.lr = lr
        self.w = [0.0]*n; self.b = 0.0
        self._load()

    def _load(self):
        if os.path.exists(MODEL_FILE):
            try:
                with open(MODEL_FILE, "rb") as f:
                    d = pickle.load(f)
                    self.w = d.get("w", self.w)
                    self.b = d.get("b", self.b)
                print("[model] loaded")
            except Exception as e:
                print("[model] load error:", e)

    def save(self):
        try:
            with open(MODEL_FILE, "wb") as f:
                pickle.dump({"w": self.w, "b": self.b}, f)
        except Exception as e:
            print("[model] save error:", e)

    def predict_proba(self, x):
        z = self.b
        for i in range(min(len(x), self.n)):
            try:
                z += self.w[i] * x[i]
            except:
                pass
        if z > 20: return 0.999
        if z < -20: return 0.001
        return 1.0/(1.0+math.exp(-z))

    def update(self, x, y):
        pred = 1 if self.predict_proba(x) >= 0.5 else 0
        if pred == y: return
        sign = 1 if y == 1 else -1
        for i in range(min(len(x), self.n)):
            try:
                self.w[i] += self.lr * sign * x[i]
            except:
                pass
        self.b += self.lr * sign
        self.save()

model = SimpleLinearModel()

# --------------------------- helpers ---------------------------------------
HEADERS = {"User-Agent": USER_AGENT, "Accept": "application/json"}

def http_get(url, params=None, timeout=15):
    try:
        r = requests.get(url, params=params, headers=HEADERS, timeout=timeout)
        if r.status_code == 200:
            return r.json()
        else:
            print(f"[http] {r.status_code} {url} params={params}")
            return None
    except Exception as e:
        print("[http] error", e, url)
        return None

def send_telegram(text, disable_notification=False):
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    data = {"chat_id": TELEGRAM_CHAT_ID, "text": text, "parse_mode": "HTML"}
    if disable_notification:
        data["disable_notification"] = "true"
    try:
        r = requests.post(url, data=data, timeout=10)
        if r.status_code != 200:
            print("[tg] send failed", r.status_code, r.text[:200])
            return False
        return True
    except Exception as e:
        print("[tg] exception", e)
        return False

def now_str():
    return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")

# ------------------------ Binance data ------------------------------------
def get_futures_symbols():
    url = BINANCE_FAPI + "/fapi/v1/exchangeInfo"
    data = http_get(url)
    if not data:
        return []
    symbols = [s["symbol"] for s in data.get("symbols", []) if s.get("symbol","").endswith("USDT") and s.get("status") == "TRADING"]
    STATE.data["stats"]["symbols_count"] = len(symbols)
    print(f"[symbols] found {len(symbols)} USDT symbols")
    return symbols

def get_klines(symbol, interval, limit=200):
    url = BINANCE_FAPI + "/fapi/v1/klines"
    params = {"symbol": symbol, "interval": interval, "limit": limit}
    data = http_get(url, params=params)
    if not data:
        return None
    opens=[]; highs=[]; lows=[]; closes=[]; vols=[]; times=[]
    for row in data:
        times.append(int(row[0])); opens.append(float(row[1])); highs.append(float(row[2]))
        lows.append(float(row[3])); closes.append(float(row[4])); vols.append(float(row[5]))
    return {"time": times, "open": opens, "high": highs, "low": lows, "close": closes, "volume": vols}

# ---------------------- indicators (pure python) ---------------------------
def sma(values, period):
    if len(values) < period: return None
    return sum(values[-period:]) / period

def ema(values, period):
    if len(values) < period: return None
    k = 2.0 / (period + 1.0)
    ema_prev = sum(values[:period]) / period
    for price in values[period:]:
        ema_prev = price * k + ema_prev * (1 - k)
    return ema_prev

def rsi(values, period=14):
    if len(values) < period + 1: return None
    deltas = [values[i] - values[i-1] for i in range(1, len(values))]
    gains = [d if d>0 else 0 for d in deltas[:period]]
    losses = [-d if d<0 else 0 for d in deltas[:period]]
    if len(gains) < period: return None
    avg_gain = sum(gains)/period
    avg_loss = sum(losses)/period
    for d in deltas[period:]:
        gain = d if d>0 else 0
        loss = -d if d<0 else 0
        avg_gain = (avg_gain*(period-1) + gain)/period
        avg_loss = (avg_loss*(period-1) + loss)/period
    if avg_loss == 0:
        return 100.0
    rs = avg_gain / avg_loss
    return 100.0 - (100.0/(1.0+rs))

def macd_line(values, fast=12, slow=26, signal=9):
    if len(values) < slow + signal: return (None, None)
    def ema_series(vals, p):
        res=[]; k = 2.0/(p+1.0)
        seed = sum(vals[:p])/p
        res=[seed]
        for v in vals[p:]:
            res.append(v*k + res[-1]*(1-k))
        return res
    fast_s = ema_series(values, fast)
    slow_s = ema_series(values, slow)
    offset = len(fast_s) - len(slow_s)
    macd_s = [fast_s[i+offset] - slow_s[i] for i in range(len(slow_s))]
    if len(macd_s) < signal: return (None, None)
    sig_seed = macd_s[:signal]
    avg = sum(sig_seed)/signal
    k2 = 2.0/(signal+1.0)
    for x in macd_s[signal:]:
        avg = x*k2 + avg*(1-k2)
    return (macd_s[-1], avg)

# --------------------------- feature builder -------------------------------
def build_feature_vector(df15):
    try:
        cur_close = df15["close"][-1]
        prev_close = df15["close"][-6] if len(df15["close"])>6 else df15["close"][0]
        ret = (cur_close/prev_close)-1.0
        r = rsi(df15["close"],14) or 50.0
        macd_v, macd_s = macd_line(df15["close"])
        macd_diff = 0.0
        if macd_v is not None and macd_s is not None:
            macd_diff = macd_v - macd_s
        vol_sma = sma(df15["volume"],20) or 1.0
        vol_mult = df15["volume"][-1] / max(1.0, vol_sma)
        ema9 = ema(df15["close"],9) or cur_close
        ema21 = ema(df15["close"],21) or cur_close
        ema_slope = (ema9 - ema21)/max(1e-8, cur_close)
        feat = [
            ret,
            r/100.0,
            macd_diff,
            vol_mult,
            ema_slope,
            math.log1p(cur_close),
            math.log1p(df15["volume"][-1]),
            1.0
        ]
        return feat
    except Exception as e:
        print("[feat] build error", e)
        return [0.0]*8

# ---------------------- smart rebound threshold ---------------------------
def smart_rebound_threshold(df15):
    closes = df15["close"]
    n = min(len(closes), VOL_LOOKBACK)
    if n < 2:
        return 0.015
    abs_changes = []
    for i in range(-n+1, 0):
        prev = closes[i-1]
        cur = closes[i]
        if prev == 0:
            continue
        abs_changes.append(abs((cur - prev)/prev))
    if not abs_changes:
        return 0.015
    vol = sum(abs_changes)/len(abs_changes)
    if vol < 0.015:
        return 0.015
    if vol < 0.03:
        return 0.025
    return 0.035

# --------------------------- signal detection ------------------------------
def detect_signal(symbol, df15, df6h, df3d):
    try:
        closes = df15["close"]; highs = df15["high"]; lows = df15["low"]; vols = df15["volume"]
        if len(closes) < MIN_CANDLES:
            return None
        price = closes[-1]
        prev_high_20 = max(highs[-21:-1]) if len(highs) >= 21 else max(highs)
        prev_low_20 = min(lows[-21:-1]) if len(lows) >= 21 else min(lows)
        vol_sma20 = sma(vols, 20) or 0.0

        buy_reasons = []
        sell_reasons = []

        if price > prev_high_20 and vols[-1] > max(1.0, vol_sma20):
            buy_reasons.append("ÙƒØ³Ø± Ù…Ù‚Ø§ÙˆÙ…Ø© + Ø­Ø¬Ù… Ù…Ø±ØªÙØ¹")
        if price < prev_low_20 and vols[-1] > max(1.0, vol_sma20):
            sell_reasons.append("ÙƒØ³Ø± Ø¯Ø¹Ù… + Ø­Ø¬Ù… Ù…Ø±ØªÙØ¹")

        rsi_val = rsi(closes, 14)
        if rsi_val is not None:
            if rsi_val < 30:
                buy_reasons.append("RSI Ù‚Ø§Ø¹")
            elif rsi_val > 70:
                sell_reasons.append("RSI Ø°Ø±ÙˆØ©")

        macd_v, macd_s = macd_line(closes)
        if macd_v is not None and macd_s is not None:
            if macd_v > macd_s:
                buy_reasons.append("MACD Ø¥ÙŠØ¬Ø§Ø¨ÙŠ")
            else:
                sell_reasons.append("MACD Ø³Ù„Ø¨ÙŠ")

        ema9 = ema(closes, 9); ema21 = ema(closes, 21)
        if ema9 is not None and ema21 is not None:
            if price > ema9 > ema21:
                buy_reasons.append("EMA ØµØ§Ø¹Ø¯")
            if price < ema9 < ema21:
                sell_reasons.append("EMA Ù‡Ø§Ø¨Ø·")

        explosive_score = 0.0
        vol_mult = (vols[-1] / max(1.0, vol_sma20)) if vol_sma20 > 0 else 0.0
        if vol_mult >= EXPLOSION_VOL_MULTIPLIER:
            explosive_score += 1.0
        try:
            if df6h and len(df6h["close"]) >= 2:
                ch6 = df6h["close"][-1] / df6h["close"][-2] - 1.0
                if ch6 > 0.03:
                    explosive_score += 1.0
        except:
            pass
        if ema9 and ema21 and ema9 > ema21:
            explosive_score += 0.5

        is_buy = (len(buy_reasons) >= 2) or (explosive_score >= 1.0)
        is_sell = (len(sell_reasons) >= 2)

        if not is_buy and not is_sell:
            return None

        side = "BUY" if is_buy else "SELL"
        entry = price
        stop_loss = entry * (0.945 if side == "BUY" else 1.055)
        target_1 = entry * (1.01 if side == "BUY" else 0.99)
        target_2 = entry * (1.02 if side == "BUY" else 0.98)

        fv = build_feature_vector(df15)
        conf = model.predict_proba(fv)

        sig = {
            "symbol": symbol,
            "side": side,
            "entry": round(entry, 8),
            "stop_loss": round(stop_loss, 8),
            "target_1": round(target_1, 8),
            "target_2": round(target_2, 8),
            "reasons": buy_reasons if side == "BUY" else sell_reasons,
            "explosive_score": round(explosive_score, 3),
            "rsi": round(rsi_val, 2) if rsi_val is not None else None,
            "macd": round(macd_v, 6) if macd_v is not None else None,
            "confidence_model": round(conf, 3),
            "timestamp": now_str()
        }
        return sig
    except Exception as e:
        print("[detect] error", symbol, e)
        return None

# ------------------------- message formatting ------------------------------
def format_signal_message(sig):
    sym_clean = sig["symbol"].replace("USDT", "")
    reasons_text = " | ".join(sig.get("reasons", [])) or "â€”"
    message = (
        f"${sym_clean}\n"
        "ğŸŸ¢ ğŸ¯ Ø®Ø·Ø© Ø§Ù„ØµÙÙ‚Ø© (Ù„Ù„Ø¹Ù‚ÙˆØ¯ Ø§Ù„Ø¢Ø¬Ù„Ø©)\n"
        f"ğŸš€ {sig['side']} {sig['symbol']}\n"
        f"ğŸ’° Ø¯Ø®ÙˆÙ„: {sig['entry']:.8f}\n"
        f"ğŸ¯ Ø§Ù„Ù‡Ø¯Ù 1ï¸âƒ£: {sig['target_1']:.8f}\n"
        f"ğŸ¯ Ø§Ù„Ù‡Ø¯Ù 2ï¸âƒ£: {sig['target_2']:.8f}\n"
        f"â›” ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø©: {sig['stop_loss']:.8f}\n"
        f"ğŸ“Š RSI={sig.get('rsi')} | MACD={sig.get('macd')}\n"
        f"ğŸ”¥ Ø§Ù†ÙØ¬Ø§Ø± Ù…Ø­ØªÙ…Ù„ score={sig.get('explosive_score')}\n"
        f"ğŸ” Ø³Ø¨Ø¨ Ø§Ù„Ø¯Ø®ÙˆÙ„: {reasons_text}\n"
        f"ğŸ“ˆ ModelConf={sig.get('confidence_model')}\n"
        f"ğŸ•’ {sig.get('timestamp')} (UTC)\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        "âš ï¸ Ù„ÙŠØ³Øª Ù†ØµÙŠØ­Ø© Ù…Ø§Ù„ÙŠØ© â€” Ø§Ø³ØªØ®Ø¯Ù… Ø¥Ø¯Ø§Ø±Ø© Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„."
    )
    return message

# --------------------------- signal handling -------------------------------
def can_send_signal(symbol):
    meta = STATE.data["sent_signals"].get(symbol)
    if not meta:
        return True
    sent_at = meta.get("sent_at", 0)
    return (time.time() - sent_at) > COOLDOWN_SECONDS

def record_and_send(sig, df15=None):
    symbol = sig["symbol"]
    if not can_send_signal(symbol):
        print(f"[dedupe] skipping {symbol} due to cooldown")
        return
    reb_thr = 0.015
    try:
        if df15:
            reb_thr = smart_rebound_threshold(df15)
    except Exception:
        reb_thr = 0.015
    STATE.data["sent_signals"][symbol] = {
        "sig": sig,
        "sent_at": time.time(),
        "monitored": True,
        "last_price": sig["entry"],
        "rebound_threshold": reb_thr
    }
    STATE.data["stats"]["signals"] += 1
    STATE.save()
    txt = format_signal_message(sig)
    ok = send_telegram(txt)
    print(f"[sent] {symbol} {sig['side']} sent -> telegram {ok} | rebound_thr={reb_thr}")

# --------------------------- monitor (follow trades) -----------------------
def monitor_loop():
    print(f"[monitor] started (interval {MONITOR_INTERVAL}s)")
    while True:
        try:
            symbols = list(STATE.data["sent_signals"].keys())
            for s in symbols:
                meta = STATE.data["sent_signals"].get(s)
                if not meta or not meta.get("monitored", True):
                    continue
                sig = meta["sig"]
                url = BINANCE_FAPI + "/fapi/v1/ticker/price"
                data = http_get(url, params={"symbol": s})
                if not data:
                    continue
                price = float(data.get("price", 0.0))
                meta["last_price"] = price
                entry = float(sig["entry"])
                side = sig["side"]
                reb_thr = meta.get("rebound_threshold", 0.015)
                # BUY checks
                if side == "BUY":
                    if price >= sig["target_2"]:
                        send_telegram(f"ğŸ‰ ${s.replace('USDT','')} - Ù…ÙƒØ³Ø¨ ÙƒØ§Ù…Ù„ (ÙˆØµÙ„ Ø§Ù„Ù‡Ø¯Ù 2) | Ø§Ù„Ø³Ø¹Ø±: {price:.8f}")
                        STATE.data["stats"]["wins"] += 1
                        try:
                            fv = build_feature_vector({"close":[entry, price], "volume":[1,1]})
                            model.update(fv, 1)
                        except: pass
                        STATE.data["sent_signals"].pop(s, None); STATE.save(); continue
                    if price <= sig["stop_loss"]:
                        send_telegram(f"âŒ ${s.replace('USDT','')} - ÙˆÙ‚Ù Ø®Ø³Ø§Ø±Ø© Ù…ÙØ¹Ù„ | Ø§Ù„Ø³Ø¹Ø±: {price:.8f}")
                        STATE.data["stats"]["losses"] += 1
                        try:
                            fv = build_feature_vector({"close":[entry, price], "volume":[1,1]})
                            model.update(fv, 0)
                        except: pass
                        STATE.data["sent_signals"].pop(s, None); STATE.save(); continue
                    drop = (price - entry) / entry
                    if drop <= -reb_thr:
                        send_telegram(f"âš ï¸ ØªÙ†Ø¨ÙŠÙ‡ Ø§Ø±ØªØ¯Ø§Ø¯ Ù‚ÙˆÙŠ ${s.replace('USDT','')} - Ù‡Ø¨ÙˆØ· {drop*100:.2f}% Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø´Ø§Ø±Ø© | Ø§Ù„Ø³Ø¹Ø±: {price:.8f}")
                else:
                    # SELL checks
                    if price <= sig["target_2"]:
                        send_telegram(f"ğŸ‰ ${s.replace('USDT','')} - Ù…ÙƒØ³Ø¨ ÙƒØ§Ù…Ù„ (ÙˆØµÙ„ Ø§Ù„Ù‡Ø¯Ù 2 Ù„Ù„Ù€ SELL) | Ø§Ù„Ø³Ø¹Ø±: {price:.8f}")
                        STATE.data["stats"]["wins"] += 1
                        try:
                            fv = build_feature_vector({"close":[entry, price], "volume":[1,1]})
                            model.update(fv, 1)
                        except: pass
                        STATE.data["sent_signals"].pop(s, None); STATE.save(); continue
                    if price >= sig["stop_loss"]:
                        send_telegram(f"âŒ ${s.replace('USDT','')} - ÙˆÙ‚Ù Ø®Ø³Ø§Ø±Ø© Ù…ÙØ¹Ù„ Ù„Ù„Ù€ SELL | Ø§Ù„Ø³Ø¹Ø±: {price:.8f}")
                        STATE.data["stats"]["losses"] += 1
                        try:
                            fv = build_feature_vector({"close":[entry, price], "volume":[1,1]})
                            model.update(fv, 0)
                        except: pass
                        STATE.data["sent_signals"].pop(s, None); STATE.save(); continue
                    rise = (price - entry) / entry
                    if rise >= reb_thr:
                        send_telegram(f"âš ï¸ ØªÙ†Ø¨ÙŠÙ‡ Ø§Ø±ØªØ¯Ø§Ø¯ (Ø¹ÙƒØ³) ${s.replace('USDT','')} - ØµØ¹ÙˆØ¯ {rise*100:.2f}% Ø¨Ø¹Ø¯ Ø¥Ø´Ø§Ø±Ø© Ø¨ÙŠØ¹ | Ø§Ù„Ø³Ø¹Ø±: {price:.8f}")
            STATE.save()
        except Exception as e:
            print("[monitor] error", e)
        time.sleep(MONITOR_INTERVAL)

# --------------------------- ping projects (keep-alive) --------------------
def ping_projects():
    while True:
        for url in PING_URLS:
            try:
                r = requests.get(url, timeout=10)
                status = r.status_code
                print(f"[ping] {url} -> {status}")
                if SEND_PING_TO_TELEGRAM:
                    send_telegram(f"ğŸ” keep-alive ping -> {url} | {status} | {now_str()}", disable_notification=True)
            except Exception as e:
                print(f"[ping] error -> {url} : {e}")
                send_telegram(f"âš ï¸ ping error -> {url} : {e} | {now_str()}")
        time.sleep(PING_INTERVAL)

# --------------------------- scanning loops --------------------------------
def scan_symbol_sync(symbol):
    try:
        df15 = get_klines(symbol, "15m", limit=200)
        df6h = get_klines(symbol, "6h", limit=50)
        df3d = get_klines(symbol, "3d", limit=200)
        if not df15:
            return
        sig = detect_signal(symbol, df15, df6h, df3d)
        if sig:
            fv = build_feature_vector(df15)
            conf = model.predict_proba(fv)
            if conf >= 0.35 or sig.get("explosive_score", 0.0) >= 1.0:
                record_and_send(sig, df15=df15)
            else:
                print(f"[filter] {symbol} filtered by model conf {conf}")
        STATE.data["stats"]["scans"] += 1
        STATE.data["last_seen"] = now_str()
        if STATE.data["stats"]["scans"] % 100 == 0:
            STATE.save()
    except Exception as e:
        print("[scan] error", symbol, e)

def full_scan_loop():
    print("[full_scan] started")
    symbols = get_futures_symbols()
    if not symbols:
        print("[full_scan] no symbols, exiting")
        return
    last_full = 0
    while True:
        now_t = time.time()
        if now_t - last_full >= FULL_SCAN_INTERVAL:
            print("[full_scan] running full scan at", now_str())
            for i, sym in enumerate(symbols):
                scan_symbol_sync(sym)
                time.sleep(SLEEP_BETWEEN_REQUESTS)
                if (i+1) % LIGHT_BATCH_SIZE == 0:
                    time.sleep(LIGHT_BATCH_SLEEP)
            last_full = now_t
            symbols = get_futures_symbols()
        time.sleep(5)

def light_scan_loop():
    print("[light_scan] started")
    symbols = get_futures_symbols()
    if not symbols:
        print("[light_scan] no symbols, exiting")
        return
    n = len(symbols); idx = 0
    while True:
        window = max(1, int(n/200) + 1)
        batch = symbols[idx: idx+window]
        if not batch:
            idx = 0; time.sleep(1); continue
        for sym in batch:
            scan_symbol_sync(sym)
            time.sleep(SLEEP_BETWEEN_REQUESTS)
        idx += window
        if idx >= n:
            idx = 0
            symbols = get_futures_symbols()
        time.sleep(LIGHT_BATCH_SLEEP)

# --------------------------- status reporter -------------------------------
def status_reporter():
    while True:
        try:
            s = STATE.data["stats"]
            last = STATE.data.get("last_seen") or now_str()
            txt = (
                f"ğŸ“Š <b>Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª</b>\n"
                f"âœ… Ø§Ù„Ø­Ø§Ù„Ø©: Ø´ØºØ§Ù„\n"
                f"ğŸ“ˆ Ø¹Ù…Ù„Ø§Øª Ù…Ø­Ù„Ù„Ø©: {s.get('scans', 0)}\n"
                f"ğŸ” Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø±Ù…ÙˆØ² ÙÙŠ Ø§Ù„Ø³ÙˆÙ‚: {STATE.data.get('stats', {}).get('symbols_count', 0)}\n"
                f"ğŸš€ ØªÙˆØµÙŠØ§Øª Ù…ÙØ±Ø³Ù„Ø©: {s.get('signals', 0)}\n"
                f"ğŸ’° Ø±Ø¨Ø­: {s.get('wins', 0)} | Ø®Ø³Ø§Ø±Ø©: {s.get('losses', 0)}\n"
                f"ğŸ•’ Ø¢Ø®Ø± ØªØ­Ù„ÙŠÙ„: {last} UTC\n"
                f"ğŸ§¾ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø­Ø§Ù„ÙŠØ§Ù‹: {len(STATE.data.get('sent_signals', {}))} ØµÙÙ‚Ø©\n"
                "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                "âš ï¸ Ù…Ù„Ø§Ø­Ø¸Ø©: Ù‡Ø°Ù‡ ØªÙˆØµÙŠØ§Øª ÙÙ‚Ø· â€” Ù„ÙŠØ³Øª Ù†ØµÙŠØ­Ø© Ù…Ø§Ù„ÙŠØ©."
            )
            send_telegram(txt)
        except Exception as e:
            print("[status] error", e)
        time.sleep(STATUS_INTERVAL)

# ---------------------- Whale watcher (websocket) --------------------------
def format_whale_message(symbol, side, price, qty, value_usdt, ts_ms):
    t = time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(ts_ms/1000.0))
    side_ar = "Ø´Ø±Ø§Ø¡" if side == "BUY" else "Ø¨ÙŠØ¹"
    msg = (
        f"ğŸ‹ <b>ØµÙÙ‚Ø© Ø­ÙˆØª Ù…ÙƒØªØ´ÙØ©!</b>\n\n"
        f"ğŸ’± Ø²ÙˆØ¬: <b>{symbol}</b>\n"
        f"ğŸ“ˆ Ø§Ù„Ø§ØªØ¬Ø§Ù‡: <b>{side_ar}</b>\n"
        f"ğŸ’° Ø§Ù„Ù‚ÙŠÙ…Ø© (ØªÙ‚Ø±ÙŠØ¨Ø§Ù‹): <b>{value_usdt:,.2f} USDT</b>\n"
        f"ğŸ”¢ Ø§Ù„Ø³Ø¹Ø±: {price}\n"
        f"ğŸ”¢ Ø§Ù„ÙƒÙ…ÙŠØ©: {qty}\n"
        f"ğŸ•’ Ø§Ù„ÙˆÙ‚Øª (UTC): {t}\n\n"
        "âš ï¸ Ù…Ù„Ø§Ø­Ø¸Ø©: ØªØ­Ù‚Ù‚ Ø¨Ù†ÙØ³Ùƒ Ù‚Ø¨Ù„ Ø£ÙŠ Ù‚Ø±Ø§Ø± ØªØ¯Ø§ÙˆÙ„ â€” Ù‡Ø°Ù‡ ØªÙ†Ø¨ÙŠÙ‡Ø§Øª ÙÙ‚Ø·."
    )
    return msg

def handle_trade_event(evt):
    try:
        # wrapper {"stream":..., "data":...}
        if isinstance(evt, dict) and "data" in evt and isinstance(evt["data"], dict):
            data = evt["data"]
        else:
            data = evt
        # sometimes list
        if isinstance(data, list):
            for d in data:
                handle_trade_event(d)
            return

        symbol = data.get("s") or data.get("S") or data.get("symbol")
        # price/qty may be strings
        price = float(data.get("p", 0) or 0)
        qty = float(data.get("q", 0) or 0)
        ts = int(data.get("T") or data.get("E") or int(time.time()*1000))
        m = data.get("m", False)
        side = "BUY" if not m else "SELL"
        value = price * qty
        # Only alert big trades
        if value >= WHALE_THRESHOLD:
            msg = format_whale_message(symbol, side, price, qty, value, ts)
            print(f"[whale] {symbol} {side} value={value:.2f} at {ts}")
            send_telegram(msg)
    except Exception as e:
        print("[handle_trade_event] error:", e)

def ws_on_message(ws, message):
    try:
        data = json.loads(message)
        if isinstance(data, dict) and "data" in data:
            handle_trade_event(data["data"])
        elif isinstance(data, list):
            for e in data:
                handle_trade_event(e)
        else:
            handle_trade_event(data)
    except Exception as e:
        print("[ws on_message] parse error:", e)

def ws_on_error(ws, error):
    print("[ws error]", error)

def ws_on_close(ws, code, msg):
    print("[ws closed] code:", code, "msg:", msg)

def ws_on_open(ws):
    print("[ws open] connected to Binance futures aggTrade stream (all symbols)")

def run_ws():
    if websocket is None:
        print("[ws] websocket-client not available, skipping whale watcher.")
        return
    while True:
        try:
            ws = websocket.WebSocketApp(
                BINANCE_WS,
                on_open=ws_on_open,
                on_message=ws_on_message,
                on_error=ws_on_error,
                on_close=ws_on_close
            )
            ws.run_forever(ping_interval=20, ping_timeout=10)
        except Exception as e:
            print("[run_ws] exception:", e)
        print(f"[run_ws] reconnecting in {WS_RECONNECT_DELAY}s...")
        time.sleep(WS_RECONNECT_DELAY)

# ------------------------------- main --------------------------------------
def start_bot():
    print("[bot] starting")
    keep_alive()

    # start threads
    ws_thread = threading.Thread(target=run_ws, daemon=True)
    ws_thread.start()

    ping_thread = threading.Thread(target=ping_projects, daemon=True)
    ping_thread.start()

    mon_thread = threading.Thread(target=monitor_loop, daemon=True)
    mon_thread.start()

    status_thread = threading.Thread(target=status_reporter, daemon=True)
    status_thread.start()

    full_thread = threading.Thread(target=full_scan_loop, daemon=True)
    full_thread.start()

    # run light scan in main thread to keep process alive
    try:
        light_scan_loop()
    except KeyboardInterrupt:
        print("[bot] interrupted, saving state...")
        STATE.save(); model.save()
    except Exception as e:
        print("[bot] fatal error:", e)
        STATE.save(); model.save()

if __name__ == "__main__":
    send_telegram(f"âœ… Ø¨ÙˆØª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¨Ø¯Ø£ Ø§Ù„Ø¢Ù† â€” ÙŠÙØ­Øµ ÙƒØ§Ù…Ù„ Ø³ÙˆÙ‚ Ø§Ù„Ø¹Ù‚ÙˆØ¯ Ø§Ù„Ø¢Ø¬Ù„Ø© (USDT) â€” {now_str()} UTC")
    start_bot()
